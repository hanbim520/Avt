
// ================================================================================================
// -*- C++ -*-
// File: vt_page_resolver.hpp
// Author: Guilherme R. Lampert
// Created on: 04/10/14
// Brief: The Page Resolver is responsible for the feedback pass analysis.
//
// License:
//  This source code is released under the MIT License.
//  Copyright (c) 2014 Guilherme R. Lampert.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
// ================================================================================================

#ifndef VTLIB_VT_PAGE_RESOLVER_HPP
#define VTLIB_VT_PAGE_RESOLVER_HPP

#include <vector>
#include <unordered_map>

namespace vt
{

class VirtualTexture;
class PageCacheMgr;
class PageProvider;

// ======================================================
// PageResolver:
// ======================================================

class PageResolver final
	: public NonCopyable
{
public:

	// Recommended size for the page-id pass FBO.
	// This size can be much smaller than the screen resolution.
	// Too small and it might loose precision. Too large and processing it will take a long time.
	// The FBO total size in pixels is this size squared, as it is a drawing surface.
	// total_fbo_pixels = ( DefaultPageIdFboSize * DefaultPageIdFboSize ).
	static constexpr int DefaultPageIdFboSize = 256;

	// Max number of new page requests the page resolver is allowed to
	// enqueue per frame. Page requests are generated by endPageIdPass().
	static constexpr int DefaultMaxPageRequestsPerFrame = 128;

	// Default constructor initializes the framebuffer with its default size.
	// Might throw and exception if initialization fails.
	explicit PageResolver(PageProvider & provider);

	// Optional constructor with user defined size for the feedback framebuffer.
	PageResolver(PageProvider & provider, int fboWidth, int fboHeight, int maxFrameRequests = DefaultMaxPageRequestsPerFrame);

	// Frees the underlaying OpenGL framebuffer.
	~PageResolver();

	// Begin the page id generation pass.
	// The appropriate shader program (pageIdGenPass) must be already bound!
	void beginPageIdPass();

	// Finish the page id generation pass, perform the feedback buffer analysis
	// and generates the page requests for a given frame.
	void endPageIdPass();

	// Visualize the page id generation pass as a screen overlay.
	// This should always be called after endPageIdPass()
	// for the output to make any sense. This is intended for debugging.
	void visualizePageIds(const float overlayScale[2]) const;

	// Number of unique visible pages for the last page generation pass.
	int getNumVisiblePages() const { return visiblePages; }

	// Get/set max per-frame request limit.
	int  getMaxPageRequestsPerFrame() const { return maxPageRequestsPerFrame; }
	void setMaxPageRequestsPerFrame(int amount) { maxPageRequestsPerFrame = amount; }

	// Register/unregister textures that use this resolver.
	// The provider will NOT copy the texture object. It only keeps a weak reference.
	void registerVirtualTexture(VirtualTexture * vtTex);
	void unregisterVirtualTexture(VirtualTexture * vtTex);
	void unregisterAllVirtualTextures();

	void addDefaultRequests();

private:

	// Internal helpers:
	void feedbackBufferAnalysis();
	int  processPageRequest(PageId requestId, PageCacheMgr & pageCache);
	void initFrameBuffer(int w, int h);

private:

	PageProvider & pageProvider;

	// New page request limit.
	int maxPageRequestsPerFrame;

	// GL framebuffer the page id pass is rendered to.
	// This framebuffer is usually much smaller than the screen resolution.
	GLuint pageIdFbo;
	GLuint fboColorTex;

	// Dimensions of the framebuffer.
	int pageIdFboWidth;
	int pageIdFboHeight;

	// We save the original framebuffer/renderbuffer.
	// This is important for compatibility with some libraries
	// such as SDL, which use a custom framebuffer.
	GLint originalFbo;
	GLint originalRbo;

	// Original OpenGL viewport, queried via glGetIntegerv.
	std::array<int, 4> originalViewport;

	// System-side buffer used to read the framebuffer in.
	// Doesn't have to be re-allocated if the framebuffer size never changes.
	std::unique_ptr<Pixel4b[]> feedbackBuffer;

	// Map of unique pages and their frequencies for the current frame:
	// <pageId, frequency>
	std::unordered_map<PageId, unsigned int> pageMap;

	// Pages generated in the current frame analysis.
	// Sorted by mip-level (higher first).
	std::vector<PageId> sortedPages;

	// Virtual textures using this resolver.
	// Just weak references. Textures must outlive the resolver.
	std::vector<VirtualTexture *> registeredTextures;

	// Counter used for debugging.
	int visiblePages;
};

} // namespace vt {}

#endif // VTLIB_VT_PAGE_RESOLVER_HPP
