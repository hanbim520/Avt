
// ================================================================================================
// -*- C++ -*-
// File: vt_page_file.hpp
// Author: Guilherme R. Lampert
// Created on: 23/10/14
// Brief: Page data backing store, usually implemented as a file on disk.
//
// License:
//  This source code is released under the MIT License.
//  Copyright (c) 2014 Guilherme R. Lampert.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
// ================================================================================================

#ifndef VTLIB_VT_PAGE_FILE_HPP
#define VTLIB_VT_PAGE_FILE_HPP

#include "vt_file_format.hpp"
#include <mutex>

namespace vt
{

struct PageRequestDataPacket;

// ======================================================
// PageFile:
// ======================================================

class PageFile
{
public:

	// Load the page pointed by 'pageId' into 'pageRequest'.
	// 'pageId' should be a valid page in the underlaying virtual texture.
	virtual void loadPage(PageId pageId, PageRequestDataPacket & pageRequest) = 0;

	// Enable/disable addition of debug info to each loaded page.
	virtual void setAddDebugInfoToPages(bool debug) = 0;
	virtual bool isAddingDebugInfoToPages() const = 0;

	// Default virtual for proper inheritance usage.
	virtual ~PageFile() = default;
};

using PageFilePtr = std::unique_ptr<PageFile>;

// ======================================================
// UnpackedImagesPageFile:
// ======================================================

class UnpackedImagesPageFile final
	: public PageFile, public NonCopyable
{
public:

	explicit UnpackedImagesPageFile(std::string directory, bool debug = false)
		: baseDir(std::move(directory)), addDebugInfo(debug) { }

	// Load a page from a loose image on disk.
	// This can be used with pages generated by the PageFileBuilder with the 'dumpPageImages' flag.
	void loadPage(PageId pageId, PageRequestDataPacket & pageRequest) override;

	void setAddDebugInfoToPages(bool debug) override { addDebugInfo = debug; }
	bool isAddingDebugInfoToPages() const   override { return addDebugInfo;  }

private:

	// Look for pages in this directory.
	// Each level should reside in a subdir named "level_x". E.g.:
	//   "pages/level_1/page_0_0.tga"
	const std::string baseDir;

	bool addDebugInfo;
};

// ======================================================
// DebugPageFile:
// ======================================================

class DebugPageFile final
	: public PageFile, public NonCopyable
{
public:

	explicit DebugPageFile(bool debug = true)
		: addDebugInfo(debug) { }

	// Fills each page request with a solid color and prints page
	// number and level on top of it. No file IO performed.
	void loadPage(PageId pageId, PageRequestDataPacket & pageRequest) override;

	void setAddDebugInfoToPages(bool debug) override { addDebugInfo = debug; }
	bool isAddingDebugInfoToPages() const   override { return addDebugInfo;  }

private:

	bool addDebugInfo;
};

// ======================================================
// VTFFPageFile:
// ======================================================

class VTFFPageFile final
	: public PageFile, public NonCopyable
{
public:

	// Initialize by attempting to open a file.
	// Throws a vt::Exception if the file cannot be opened.
	explicit VTFFPageFile(std::string filename, bool debug = false);

	// Initialize from an open file.
	// Assumes the stream is pointing to the beginning of the file.
	// Takes ownership of the file stream and closes it in the destructor.
	VTFFPageFile(FILE * fileStream, std::string filename, bool debug = false);

	// Closes the underlaying file stream.
	~VTFFPageFile();

	// Load a page from a Virtual Texture File Format (VTFF) file.
	void loadPage(PageId pageId, PageRequestDataPacket & pageRequest) override;

	// Getters/setters:
	void setAddDebugInfoToPages(bool debug) override { addDebugInfo = debug; }
	bool isAddingDebugInfoToPages() const   override { return addDebugInfo;  }

	const VTFFPageTree & getPageTree() const { return *pageTree; }
	VTFFPageTree & getPageTree() { return *pageTree; }

private:

	static bool isPowerOfTwo(uint32_t size);
	static FILE * tryOpenFile(const std::string & filename);

	// File handle owned by this class.
	FILE * pageFile;

	// In some implementations (including iOS, it seems),
	// FILEs are not thread safe. If we are concurrently accessing
	// pageFile, which is the case with an async PageProvider, this mutex is needed.
	#if VT_THREAD_SAFE_VTFF_PAGE_FILE
	std::mutex fileLock;
	#endif // VT_THREAD_SAFE_VTFF_PAGE_FILE

	// Set of all pages, as loaded from the input file.
	std::unique_ptr<VTFFPageTree> pageTree;

	const std::string inputFileName;
	bool addDebugInfo;
};

using VTFFPageFilePtr = std::unique_ptr<VTFFPageFile>;

} // namespace vt {}

#endif // VTLIB_VT_PAGE_FILE_HPP
